---
aliases:
tags:
data:
---

T代表一种类型，<T,R> 这样可以传递多种类型 

```rust

// 无法编译！
fn largest<T>(a: T, b: T) -> T {
    if a > b { // 错误：编译器不知道 T 是否可以比较
        a
    } else {
        b
    }
}
```


向编译器“承诺”，我们传入的类型 `T` **必须是**可以比较大小的。这个“承诺”或者说“能力”，在 Rust 里就是 **Trait**。

```rust
use std::cmp::PartialOrd; // 引入 PartialOrd Trait

// T: PartialOrd 就是 Trait 约束
fn largest<T: PartialOrd>(a: T, b: T) -> T {
    if a > b {
        a
    } else {
        b
    }
}

```


### Trait 就是跟编译器保证我们传入的参数可以比较是么?

是的，在咱们刚才那个 `largest` 函数的例子里，`PartialOrd` 这个 Trait 的作用，就是向编译器保证：“别担心，我传进来的参数 T，一定有能力进行比较操作！”
“可以比较”只是众多“能力”中的**一种**。**[[rust_Trait]]** 的真正含义是定义了任何一种共享的行为或能力。**

把它想象成一个**能力徽章**：

- 有一个叫 [[rust_PartialOrd]] 的徽章，代表“我能比较大小”。
    
- 还有一个非常常见的叫 [[Display]] 的徽章，代表“我能用 `println!("{}", ...)` 优美地打印出来”。
    
- 还有一个叫 [[rust_Debug]] 的徽章，代表“我能用 `println!("{:?}", ...)` 来进行调试打印”。
    
- 甚至还有 [[rust_Copy]] 徽章，代表“我被赋值时是拷贝而不是移动”。

Trait 像是赋能,Trait 就是给一个原本没有某种能力的数据类型，赋予（或者说声明）它这种能力。

### rust不能直接打印结构体是吗？

display帮我们打印结构体，整块 `impl...` 代码的目的，就是教会 Rust 如何在你要求用 `println!("{}", ...)` 打印 `Point` 结构体时，把它转换成一个我们想要的字符串

```rust

use std::fmt; // 1. 引入必要的模块

// 我们自己的结构体
struct Point {
    x: i32,
    y: i32,
}

// 2. 为 Point "赋能" Display
impl fmt::Display for Point {
    // 这是 Display Trait 要求我们必须实现的方法
    // 它的签名是固定的，照着写就行
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // 3. 核心逻辑：使用 write! 宏，告诉编译器你想怎么打印
        // f 是一个“格式化器”，你可以把它想象成一个待写入的字符串缓冲区
        write!(f, "({}, {})", self.x, self.y)
    }
}

fn main() {
    let point = Point { x: 1, y: 2 };
    // 现在，因为我们实现了 Display，所以这行代码可以完美运行了！
    println!("坐标点是：{}", point); // 输出: 坐标点是：(1, 2)
}

```

感觉 `#[derive(Debug)] println!("这是Debug输出: {:?}", point);`  更好用点

```rust

// 只需要在结构体上面加上这一行！
#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    // 使用 {:?} 占位符来调用 Debug Trait
    println!("这是Debug输出: {:?}", point);
    // 输出: 这是Debug输出: Point { x: 1, y: 2 }

    // 还有一个变体 {:#?}，可以让输出更易读（带换行和缩进）
    println!("这是美化后的Debug输出:\n{:#?}", point);
    /* 输出:
       这是美化后的Debug输出:
       Point {
           x: 1,
           y: 2,
       }
    */
}

```

