---
aliases:
tags:
data:
---

### 什么是 [[智能指针]]？

首先，我们来回忆一下普通的“ [[引用]] (`&`)”。引用是“ [[借用]] ”数据，它只是一个指向数据的地址，但并不“拥有”数据。

**智能指针**，则是一些特殊的 [[结构体]]。它们也像引用一样，可以“指向”其他数据。但不同的是，它们通常**拥有**所指向的数据，并且还附带了一些额外的“超能力”（元数据和功能）。

**一个简单的比喻：**

- **普通引用 (`&`)** 就像一张“临时访客卡”。你可以用它进入大楼，但你不能决定大楼什么时候拆除，卡片到期了就得还回去。
    
- **智能指针** 就像一张“房产证”。你不仅能进出这栋房子，你还拥有它，并且负责决定它的一切（包括何时“拆除”——释放内存）。

基础、最常见的智能指针 `Box<T>` 开始。

它的“超能力”只有一个，但非常重要：**[[rust_Box|Box<T>]]  可以把数据强制存储在“[[堆 (Heap)]]”上，而不是“[[栈 (Stack)]]”上。**


```rust

fn main() {
    // 变量 `a` 包含一个 i32 值，它直接存储在栈上。
    let a = 5;

    // 我们用 Box::new 创建一个盒子
    // 数字 10 被分配到了堆上
    // 变量 `b` 是一个 Box<i32> 类型的智能指针，它本身存放在栈上，但它指向堆上的数据。
    let b = Box::new(10);

    println!("a = {}, b = {}", a, b);

    // 当 main 函数结束时：
    // `a` 直接从栈上被移除。
    // `b` (房产证) 也从栈上被移除，因为 `b` 拥有堆上的数据，
    // 所以在它被移除的瞬间，它会自动负责把堆上那个 10 也清理掉（释放内存）。
    // 这就是 `Box` 智能的地方！它自动管理了堆内存！
}
```

Box::new(10);不只是可以放在堆上，还能帮你自动删除,这个“自动删除”的能力，是 Rust 通过一个非常特殊的 **`Drop` Trait** 来实现的

### 放在堆里面有什么用呢？

`Box` 大显身手的经典场景：**创建递归类型**

[[链表]]想象成一列火车，每个车厢 (`Node`) 都装着一些货物（一个数字），并且连接着下一节车厢

我们通常用 `enum` 来定义这种可能“有”也可能“没有”后续节点的数据结构：

```rust
// 定义一个链表 List
// 它要么是一个 Cons 节点，包含一个 i32 值和下一个 List
// 要么是 Nil，代表链表的末尾
enum List {
    Cons(i32, List),
    Nil,
}

```

让我们站在编译器的角度思考一下：

1. 为了知道一个 `List` 变量需要占用多少内存空间，我需要计算它的大小。
    
2. `List` 的大小取决于 `Cons` 和 `Nil`。`Nil` 不存数据，大小是 0。
    
3. `Cons(i32, List)` 的大小 = `i32` 的大小 + `List` 的大小。
    
4. 等等，要计算 `List` 的大小，我需要先知道 `List` 的大小？


`Box` 在这里的作用，就是斩断这个无限循环！我们不直接在 `Cons` 中包含一个 `List`，而是包含一个**指向 `List` 的 `Box`**

```rust

// 正确的可编译版本
enum List {
    Cons(i32, Box<List>), // 看！我们把 List 放进了盒子里！
    Nil,
}

use List::{Cons, Nil};

fn main() {
    // 这样，我们就可以成功创建链表了
    // 结构是：1 -> 2 -> 3 -> Nil
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil)
            ))
        ))
    );
}

```

### 为什么这样就行了？

因为 `Box<List>` 是一个智能**指针**。在 Rust 中，**任何指针的大小在编译时都是已知的、固定的**（比如在 64 位系统上是 8 字节）。

现在，编译器再来计算 `List` 的大小：

1. `Cons` 的大小 = `i32` 的大小 + **`Box<List>` 的大小**。
    
2. `i32` 的大小是 4 字节。
    
3. `Box<List>` 是个指针，它的大小是 8 字节。
    
4. 所以 `Cons` 的大小就是 4 + 8 = 12 字节。
    

问题解决了！[[编译器]] 算出了一个确切的大小，代码就可以编译了。实际的下一个 `List` 节点被 `Box` 存到了堆上，而我们在栈上只需要存储一个固定大小的指针就行了。

这个例子是不是很巧妙？`Box` 在这里就像一个“隔断”，用一个已知大小的指针，隔开了无限递归的类型定义，让编译器能够安心工作。


原先list是在栈中是么？栈空间中编译器无法识别大小，然后box给放在堆中了，用引用来链接这个链表，引用编译时都是已知的、固定的,指针是有容量和指向么？

1. 原先list是在栈中是么？栈空间中编译器无法识别大小
2. `Box` 所做的，是把**下一个 `List` 节点**放到了堆中。`Box` 本身是一个智能**指针**，这个指针留在了栈上，代替了原先那个无法确定大小的 `List` 节点的位置。
3. 无论是普通的引用 (`&T`)，还是 `Box<T>` 这样的智能指针，它们在内存中的本质就是一个** [[指针]] **。指针存储的就是一个内存地址。
4. - **纯粹的指针**。它们只有一个信息：**指向 (pointing to)**，也就是一个内存地址。它们没有“容量”或“长度”的信息。
	- **对于某些特殊的指针类型，比如“切片引用” (`&[T]`) 或 `String`：** 它们是“ [[胖指针]] ” (fat pointers)。它们内部包含了**两个**信息：
	    1. **指向 (pointing to):** 指向数据开始位置的内存地址。
	    2. **长度/容量 (length/capacity):** 数据的长度。



```
let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
```

下面就是内存布局图：

```
       STACK (栈)                                  HEAP (堆)
   +----------------------+
   | list                 |
   | -------------------- |                 +--------------------------------+
   | Cons(                |                 | Address: 0xAAAA                |
   |   value: 1,          |                 | ------------------------------ |
   |   next: (Box) ptr ---+---------------> | Cons(                          |
   | )                    |                 |   value: 2,                    |
   +----------------------+                 |   next: (Box) ptr ---+         |
                                            | )                      |       |
                                            +------------------------+       |
                                                                     |       |
                                            +------------------------+ <-------+
                                            | Address: 0xBBBB        |
                                            | ---------------------- |
                                            | Cons(                  |
                                            |   value: 3,            |
                                            |   next: (Box) ptr ---+ |
                                            | )                      | |
                                            +------------------------+ |
                                                                       |
                                            +------------------------+ <-------+
                                            | Address: 0xCCCC        |
                                            | ---------------------- |
                                            | Nil                    |
                                            +------------------------+

```

---

### 图解说明：

1. **从栈 (STACK) 开始：**
    
    - 我们的程序里有一个变量叫 `list`，它被存放在**栈**上。
        
    - 这个 `list` 变量本身就是我们链表的第一个节点 `Cons`。它包含两部分：
        
        - 值 `value: 1`。
            
        - 一个智能指针 `Box`。这个 `Box` 的内容其实就是一个指向**堆**的内存地址 (`ptr`)。
            
2. **第一个“桥梁” `Box`：**
    
    - 栈上的第一个 `Box` 指针，指向了堆上地址为 `0xAAAA` 的一块内存。
        
    - 这块内存里存放着我们链表的**第二个节点**：`Cons(value: 2, next: (Box) ptr)`。
        
    - 你看，第二个节点的数据（值 `2` 和指向下一个节点的指针）完整地存放在**堆**上。
        
3. **第二个和第三个 `Box`：**
    
    - 堆上的第二个节点里，同样包含一个 `Box` 指针，它又指向了堆上的另一块内存 `0xBBBB`。
        
    - `0xBBBB` 里存放着我们的**第三个节点**：`Cons(value: 3, ...)`。
        
    - 第三个节点里的 `Box` 指针，最终指向了堆上的 `0xCCCC`，这里存放的是链表的终点 `Nil`。
        

**核心思想总结：**

- 整个链表的数据，除了第一个节点的值 `1` 和第一个指针之外，其余所有部分都零散地存放在**堆**上。
    
- `Box` 就像一条条“锁链”，将这些分散在堆上的节点一个一个地链接起来，形成了一个完整的逻辑链表。
    
- 而在**栈**上，我们只需要一个 `list` 变量，它的大小是固定的（`i32` 的大小 + 一个指针的大小），编译器因此非常满意。
    
