---
aliases:
tags:
data:
---

### 什么是 [[智能指针]]？

首先，我们来回忆一下普通的“ [[引用]] (`&`)”。引用是“ [[借用]] ”数据，它只是一个指向数据的地址，但并不“拥有”数据。

**智能指针**，则是一些特殊的 [[结构体]]。它们也像引用一样，可以“指向”其他数据。但不同的是，它们通常**拥有**所指向的数据，并且还附带了一些额外的“超能力”（元数据和功能）。

**一个简单的比喻：**

- **普通引用 (`&`)** 就像一张“临时访客卡”。你可以用它进入大楼，但你不能决定大楼什么时候拆除，卡片到期了就得还回去。
    
- **智能指针** 就像一张“房产证”。你不仅能进出这栋房子，你还拥有它，并且负责决定它的一切（包括何时“拆除”——释放内存）。

基础、最常见的智能指针 `Box<T>` 开始。

它的“超能力”只有一个，但非常重要：**[[Box<T>]]  可以把数据强制存储在“[[堆 (Heap)]]”上，而不是“[[栈 (Stack)]]”上。**


```rust

fn main() {
    // 变量 `a` 包含一个 i32 值，它直接存储在栈上。
    let a = 5;

    // 我们用 Box::new 创建一个盒子
    // 数字 10 被分配到了堆上
    // 变量 `b` 是一个 Box<i32> 类型的智能指针，它本身存放在栈上，但它指向堆上的数据。
    let b = Box::new(10);

    println!("a = {}, b = {}", a, b);

    // 当 main 函数结束时：
    // `a` 直接从栈上被移除。
    // `b` (房产证) 也从栈上被移除，因为 `b` 拥有堆上的数据，
    // 所以在它被移除的瞬间，它会自动负责把堆上那个 10 也清理掉（释放内存）。
    // 这就是 `Box` 智能的地方！它自动管理了堆内存！
}
```

Box::new(10);不只是可以放在堆上，还能帮你自动删除,这个“自动删除”的能力，是 Rust 通过一个非常特殊的 **`Drop` Trait** 来实现的

### 放在堆里面有什么用呢?
