---
aliases:
tags:
data:
---
## 引言

### Rust的学习挑战

Rust语言在业界以其陡峭的学习曲线而闻名。然而，这种挑战并非一道无法逾越的障碍，而是一种前置的智力投资。它要求开发者在学习初期就深入理解系统编程中的独特概念，尤其是所有权（Ownership）、借用（Borrowing）和生命周期（Lifetimes）。一旦掌握了这些核心原则，开发者将获得构建在编译时就能保证内存安全和线程安全的高效软件的能力，从而从根本上消除诸如空指针解引用、数据竞争和缓冲区溢出等常见问题。这种设计哲学赋予了开发者强大的能力，使其能够自信地在从命令行工具、后端服务到嵌入式系统等多样化的领域中构建高度可靠的软件。  

### 报告的理念与结构

本报告的核心论点是：真正精通Rust的路径，是通过一种结构化的、分阶段的刻意练习来达成的。仅仅阅读文档或观看视频是远远不够的；必须通过亲手编写代码、解决问题和构建项目，才能将理论知识内化为实践技能。为此，本报告构建了一个三阶段的教学框架，旨在系统性地引导学习者从入门到精通：

1. **基础阶段 (Foundational Stage):** 此阶段的目标是获取核心知识，理解Rust的思维模型，并能流利地与编译器进行“对话”，理解其错误信息。
    
2. **强化阶段 (Reinforcement Stage):** 此阶段专注于巩固地道的（idiomatic）编程实践，并通过解决更复杂的问题来磨练算法和数据结构的运用能力。
    
3. **应用阶段 (Application Stage):** 此阶段旨在通过构建复杂的、真实世界的系统来达成深度掌握，将所有学到的知识融会贯通。
    

本报告将逐一剖析每个阶段的关键学习资源、练习平台和项目类型，并提供一份经过深入分析的、可操作的路线图，以帮助不同水平的开发者规划其学习路径。

---

## 第一部分：基础阶段 - 构建核心能力 (初级)

此阶段的目标是为后续的学习打下坚实的基础。重点在于建立对Rust核心原则，尤其是所有权和借用检查器（Borrow Checker）的牢固理解。学习者追求的不仅仅是写出能够通过编译的代码，更要深刻理解代码_为什么_能通过编译，从而在脑海中建立起正确的Rust心智模型。

### 1.1 经典路径：理论与实践的协同

#### 核心资源：《The Rust Programming Language》 (官方圣经)

被社区亲切地称为“The Book”的《The Rust Programming Language》是由Rust核心团队成员撰写的官方权威指南，是学习Rust无可争议的首选资源。它假定读者具备其他语言的编程经验，但不限定于任何特定语言，因此受众广泛。  

该书的结构在教学法上极为出色，它巧妙地将概念章节与项目章节相结合。全书系统性地介绍了变量、数据类型、控制流等基础编程概念，然后深入探讨了Rust独有的核心特性，如所有权、借用、切片、结构体、枚举和模式匹配。书中穿插的项目，例如第二章的“猜谜游戏”和第十二章的命令行  

`grep`克隆工具，为理论知识提供了即时且具体的实践应用场景，极大地促进了理解和吸收。  

为了进一步提升学习体验，布朗大学（Brown University）推出了一个实验性的交互式版本。该版本在原书的基础上增加了交互式测验和高亮笔记功能，通过即时反馈循环显著增强了知识的留存和主动学习的效果。对于偏好在学习过程中获得即时验证的学习者而言，强烈推荐使用此版本。  

#### 必备伴侣：Rustlings

Rustlings项目包含一系列精心设计的小型练习，旨在让学习者习惯于阅读和编写Rust代码，特别是训练其阅读并响应编译器的错误信息。官方明确建议将Rustlings与“The Book”并行使用，以达到最佳学习效果。  

Rustlings的练习按主题进行组织（例如变量、字符串、移动语义等），并且每个练习都故意包含一个或多个编译错误，需要学习者动手修复。这个过程直接训练了Rust新手最关键的一项技能：解读编译器虽然有时冗长但极其精确的错误提示。学习者通过  

`cargo install rustlings`命令安装，并通过`rustlings init`进行初始化。其核心工作流是  

`rustlings watch`命令，它会监控文件变化并自动重新编译，提供了一个无缝的学习体验。  

#### 协同学习循环的构建

“The Book”与Rustlings的结合，创造了一个强大而高效的协同学习循环。这个循环将理论学习与实践纠错紧密地联系在一起，极大地加速了对Rust核心概念的内化过程。

其运作方式如下：

1. 学习者首先在“The Book”中阅读一个概念章节，例如第四章关于所有权的内容。  
    
2. 随后，他们转向Rustlings，开始解决`exercises/move_semantics/`或`exercises/variables/`目录下的相关练习。  
    
3. 在尝试编译时，编译器会报告一个错误。此时，学习者必须回忆并运用刚刚从“The Book”中学到的理论知识，来理解错误的本质并找出正确的修复方法。
    
4. 这个“理论输入 -> 实践应用 -> 错误反馈 -> 修正理解”的闭环，相比于单纯的被动阅读或编写无错代码，能够更深刻地将Rust的心智模型烙印在学习者的脑海中。这正是官方推荐的初学者路径的精髓所在，它让学习者不再畏惧编译器，而是将其视为一位严格而有益的导师。
    

### 1.2 其他及补充性基础资源

#### 面向代码优先的学习者：Rust by Example (RBE)

Rust by Example (RBE)是另一项官方资源，它通过一系列可运行的代码示例来阐述Rust的各种概念，并配以最少的文字说明。它被定位为“The Book”的一种替代方案，特别适合那些偏好从具体代码中学习，而非通过大量文字描述来理解概念的开发者。RBE同样包含了练习题，为实践提供了机会。对于经验丰富的程序员来说，RBE是一个极佳的快速参考手册，他们可以从语法和示例中迅速推断出语言的机制。然而，对于像生命周期这样蕴含深刻设计哲学的特性，RBE的简洁性可能不足以传达其全部内涵，此时“The Book”的详尽解释则显得不可或缺。  

#### 面向视觉/听觉学习者：视频课程与教程

对于偏好视觉和听觉学习方式的开发者，网络上存在丰富的视频资源。例如，“Let's Get Rusty”系列视频与“The Book”的章节同步，提供了可视化的讲解。FreeCodeCamp等平台也推出了全面的Rust速成课程。此外，还有一些训练营式的长视频，能够在数小时内系统性地讲解从基础语法到内存管理、结构体等高级主题。这些资源非常适合用于建立对Rust的初步概览，或借助视觉辅助来理解复杂概念。然而，必须强调的是，观看视频应始终与主动的编码实践（如完成Rustlings练习）相结合，以避免陷入被动学习的陷阱，确保知识的真正掌握。  

---

## 第二部分：强化阶段 - 巩固地道的Rust编程 (中级)

当学习者掌握了Rust的基础语法和核心概念后，学习的重心便从编写_正确_的Rust代码，转向编写_地道_（idiomatic）的Rust代码。这一阶段要求学习者超越简单的练习，开始解决更复杂的问题，并熟练运用标准库中强大的功能和社区中沉淀下来的通用模式。

### 2.1 面向地道代码的结构化实践：Exercism

Exercism为Rust提供了一个专门的学习路径，其中包含了大量的编码练习。与其他一些平台不同，Exercism更侧重于通过实践和导师指导来提升代码质量，尽管其教学大纲仍在不断完善中。它被定位为一个练习工具，而非主要的学习平台。  

Exercism的优势在于其问题设计。这些问题往往能引导学习者思考API设计、数据结构选择，并以一种“Rust风格”的方式运用标准库的特性，如迭代器和枚举。平台的一大特色是，在学习者提交自己的解决方案后，可以查看其他社区成员的解法。这是一个极其宝贵的学习机会，通过对比分析，可以发现更多样化、更地道的实现方式。此外，Exercism的系统设计中包含了导师（Mentor）角色，像  

`awesome-rust-mentors`这样的社区项目也列出了愿意为Exercism问题提供指导的导师。这为中级学习者提供了一条获得关于代码风格和编程范式反馈的有效途径，而这种反馈在提升代码质量的关键阶段至关重要。  

### 2.2 游戏化学习与社区智慧：Codewars

Codewars是一个提供大量由社区创建的编码挑战（称为“kata”）的平台，并且对Rust有很好的支持。这些挑战通过“kyu”等级系统来划分难度，其中8 kyu为最简单。  

Codewars的特长在于它提供了海量、短小精悍的练习题，覆盖了算法、数据结构和基础知识等广泛的主题。该平台的核心学习机制在于，完成一个kata后，用户可以查看并投票给其他用户的解决方案。这使得学习者能够接触到社区中各种巧妙、简洁且高度地道的代码。通过研究这些高票答案，学习者可以快速学习到如何有效利用Rust的函数式特性（如  

`map`、`filter`和闭包），以及发现那些自己可能忽略了的标准库函数。为了高效地利用Codewars，学习者在提交了自己的可行解法后，应投入相当的时间进行“对比与反思”，仔细研究社区中的优秀答案，从而提炼出更符合Rust风格的编程模式。  

### 2.3 算法试炼场：对LeetCode的批判性审视

LeetCode是算法练习和技术面试准备的领先平台，它为Rust提供了支持。在GitHub等社区中，可以找到大量用Rust编写的LeetCode题解仓库。  

然而，在Rust社区中，一个反复出现且值得重视的观点是，LeetCode可能会引导学习者养成“不良的编程习惯”和编写“非地道的Rust代码”。主要的批评集中在以下两点：  

- **自引用数据结构：** 许多涉及链表或图的题目，在安全的Rust中实现起来极其“不符合人体工程学”（unergonomic）。这是因为借用检查器严格限制了可变引用的别名。为了绕过这一限制，标准的LeetCode式Rust解法通常会使用`Option<Rc<RefCell<Node>>>`这样的复杂模式。虽然技术上可行，但这在真实的Rust应用中很少是最佳实践。地道的Rust代码在处理这类问题时，往往会采用基于  
    
    `Vec`索引的“竞技场分配”（arena allocation）模式，从而在逻辑上绕开所有权难题。
    
- **不规范的函数签名：** 平台上的题目有时会要求函数接受`String`类型的值，而不是更通用的`&str`切片；或者使用平台自定义的、非标准的链表等数据结构。这些做法与Rust社区推崇的API设计原则相悖。  
    

尽管存在这些批评，LeetCode的价值依然不容忽视。它为纯粹的算法思维训练提供了绝佳的平台。许多开发者认为，用Rust解决LeetCode问题是一种有趣的体验，并且能直观地感受到Rust的卓越性能——很多解法都能轻松获得“0ms”的运行时成绩。  

#### LeetCode作为理解Rust价值的苏格拉底式工具

在LeetCode上用Rust解决某些问题时遇到的阻力和“不便”，并非平台或语言的缺陷，而是一堂极具价值的实践课。它深刻地揭示了Rust所有权和借用规则存在的根本原因。这个过程迫使开发者直面那些Rust旨在从编译层面根除的bug类别，例如悬垂指针和数据竞争。

这个学习过程可以被看作是与借用检查器的一场苏格拉底式的对话：

1. 一位有C++背景的开发者，试图在LeetCode上用常规的指针或引用方式实现一个双向链表。
    
2. 他会立刻碰壁，编译器会抛出大量关于多个可变引用的错误。
    
3. 挫败感促使他去研究，最终发现了`Rc<RefCell<T>>`模式。他实现了这个模式，代码通过了，但整个过程感觉异常复杂和冗长。  
    
4. 这次经历引发了一个更深层次的问题：“为什么在Rust里这么难？”答案是：Rust强迫他显式地处理共享可变性，而在C++中，这项任务是隐式的，并且充满了潜在的风险。
    
5. 这个顿悟改变了练习的性质。目标不再仅仅是“解决这道LeetCode题”，而是理解其背后的权衡。开发者会认识到，对于这类问题，更地道的Rust方法可能是使用基于`Vec`的索引，这种方法从根本上避免了所有权的复杂性。
    
6. 因此，当以这种探索性的心态去使用LeetCode时，它就从一个单纯的算法测试平台，转变为一个与借用检查器深度交流的工具。它教会开发者如何真正地“用Rust思考”，并欣赏其提供的安全保障，而不是仅仅将其他语言的模式生硬地翻译过来。
    

### 表1：中级练习平台分析

为了帮助学习者根据其当前目标做出明智的选择，下表对几个主流的中级练习平台进行了多维度比较。

|特性|Exercism|Codewars|LeetCode|
|---|---|---|---|
|**问题风格**|精心策划的、与教学大纲相关联的练习|游戏化的、短小精悍的“kata”|经典的算法与数据结构挑战|
|**地道代码侧重**|**高** (鼓励良好的API设计，多用`std`特性)|**中** (通过社区优秀答案学习地道用法)|**低** (题目限制有时会迫使使用非地道模式)|
|**反馈机制**|导师指导 (可选)、社区解决方案|社区解决方案 (可投票排序)|性能指标 (运行时/内存)、讨论区|
|**主要学习目标**|掌握地道的Rust编程、API设计|快速、大量的练习，学习`std`库的技巧|算法问题解决能力、技术面试准备|
|**最适用人群**|期望编写生产级质量代码的中级开发者|享受游戏化学习并乐于从多样化解法中学习的开发者|准备技术面试或专注于纯算法训练的开发者|

导出到 Google 表格

---

## 第三部分：应用阶段 - 构建真实世界系统 (高级)

这一阶段的核心是“综合”：将语法知识、编程范式和对生态系统的了解结合起来，用于构建有实质性规模的项目。这是通往真正精通的必经之路，也是锻造深度理解的熔炉。

### 3.1 “构建你自己的X” (BYOX) 模式

“构建你自己的X”（Build Your Own X）是一种极其有效的学习方法，它要求学习者从零开始重新实现一个复杂的软件系统，例如数据库、Shell、编译器或游戏引擎。对于像Rust这样的系统级编程语言，这种方法尤其强大，因为它迫使学习者深入理解底层原理。  

网络上有许多专门整理BYOX教程的资源库。其中，`osynavets/build-your-own-x-in-rust`这个GitHub仓库是一个典范，它分门别类地列出了用Rust构建数据库、网络协议栈、操作系统、游戏等项目的教程。另一个泛用性的资源是  

`practical-tutorials/project-based-learning`。  

#### 指导性构建平台：CodeCrafters

CodeCrafters提供了一种独特的、高度结构化的BYOX学习体验。它提供一系列挑战，引导用户构建诸如Redis、Git、SQLite等生产级工具的简化版。该平台明确将自己定位为超越“为初学者设计的教程”，专注于真实世界的系统实现，而非玩具问题。  

CodeCrafters的教学模式基于Git工作流，并为项目的每个阶段提供自动化测试。这种模式将一项看似艰巨的宏大任务，分解为一系列可管理的、循序渐进的步骤。每个步骤完成后，学习者都能通过运行测试获得即时反馈。这种即时反馈循环是传统的书籍或博客教程所缺乏的，它极大地降低了学习高级项目的门槛，使其成为高级学习者手中一件异常强大的工具。  

### 3.2 特定领域的项目深度探索

本节将为不同技术方向的开发者提供一份精选的高价值项目列表，并将这些项目与需要掌握的核心Rust概念及生态系统中的关键库（crate）联系起来。

#### 3.2.1 系统编程与高性能命令行工具

- **项目构想:** 重新实现一个经典的Unix工具，如`grep`、`ls`或`find`。
    
- **学习价值:** 这类项目是体验Rust在系统编程领域优势的绝佳入门。通过它们，可以深入学习文件I/O、命令行参数解析、错误处理和性能优化等核心技能。
    
- **关键资源:**
    
    - “The Book”的第十二章提供了一个构建`grep`克隆版的完整教程，内容涵盖参数解析、文件读取、错误处理和测试驱动开发（TDD）。  
        
    - 《Command Line Applications in Rust》是一本专门探讨如何构建健壮CLI工具的书籍，它在相关主题上提供了更深入的讲解。  
        
- **核心Crates:** `clap`（用于强大的命令行参数解析），  
    
    `anyhow`（用于简化应用级错误处理），以及将`ripgrep`项目作为追求极致性能的案例研究。  
    

#### 3.2.2 并发后端服务与Web API

- **项目构想:** 为一个博客系统构建一个RESTful API，或者使用WebSocket实现一个实时聊天服务。
    
- **学习价值:** 这个领域迫使开发者深入接触Rust强大且独特的并发和异步生态系统。学习者将掌握`async/await`语法、异步运行时的使用、状态管理、数据库交互以及现代后端服务的架构模式。
    
- **关键资源:**
    
    - 《Zero To Production In Rust》一书在社区中备受推崇，它全面地指导了如何构建一个生产级别的后端服务。  
        
    - 网络上有大量针对不同Web框架的教程，例如使用Actix-Web和PostgreSQL构建高性能REST API ，或使用Axum框架进行开发。  
        
    - 同时，也有关于如何在Rust项目中应用“整洁架构”（Clean Architecture）或“六边形架构”（Hexagonal Architecture）等高级设计模式的讨论。  
        
- **核心Crates:** `tokio`（异步运行时），  
    
    `axum`或`actix-web`（Web框架），  
    
    `sqlx`或`diesel`（数据库交互，其中`sqlx`支持编译时SQL检查），  
    
    `serde`（序列化与反序列化）。
    

#### 3.2.3 高性能WebAssembly (Wasm) 应用

- **项目构想:** 创建一个在浏览器中运行的客户端图像处理工具，或实现一个完全在前端运行的“康威生命游戏”。
    
- **学习价值:** 这个方向探索了Rust在Web领域的“一次编写，到处运行”的能力，特别是在那些对性能要求极高、JavaScript难以胜任的计算密集型任务上。它还涉及到Rust与JavaScript之间通过外部函数接口（FFI）进行交互的关键技术。
    
- **关键资源:**
    
    - 《Rust and WebAssembly》是官方指南，其中包含一个实现“康威生命游戏”的详细教程。  
        
    - 大量的在线教程演示了如何搭建一个最小化的Rust-Wasm项目，以及如何使用`wasm-pack`等工具来编译、打包代码，以便在JavaScript中调用。  
        
- **核心Crates:** `wasm-bindgen`（用于生成JS与Rust之间的绑定代码），  
    
    `yew`（一个用于构建完全由Rust和Wasm驱动的单页应用的框架）。  
    

#### 3.2.4 裸机嵌入式系统

- **项目构想:** 为STM32或树莓派等微控制器编写一个“点灯”（blinky）程序，或者更进一步，实现一个简单的操作系统内核。
    
- **学习价值:** 这是对Rust底层控制能力的终极考验。开发者将学习内存映射I/O、中断处理，以及在没有标准库（`no_std`）环境下编程的技巧。
    
- **关键资源:**
    
    - Rust嵌入式工作组提供了一套官方书籍，构成了“嵌入式Rust书架”：面向有嵌入式经验开发者的《The Embedded Rust Book》；面向纯新手的《The Discovery Book》；以及探讨深度技术细节的《The Embedonomicon》。  
        
    - `rust-raspberrypi-OS-tutorials`仓库提供了一份为树莓派编写操作系统的分步指南。  
        
- **核心概念:** `no_std`编程、硬件抽象层（HAL）、交叉编译，以及使用GDB和OpenOCD等工具进行硬件调试。  
    

#### 项目式学习作为精通的真正试金石

从解决孤立的练习题到构建一个集成的系统，是Rust学习旅程中最关键的转折点。项目开发迫使学习者走出单一概念的“舒适区”，去面对错误处理、依赖管理、模块组织和API设计等复杂因素的相互作用——而这些正是定义一个合格软件工程师的核心技能。

这个过程揭示了单纯做题无法暴露的知识盲点。例如，一个开发者可能在Rustlings中能解决任何所有权问题，在Codewars上能写出高效的算法，并因此对单个概念感到自信。然而，当他开始构建一个Web服务时，一系列全新的、系统性的问题便会涌现：我的项目模块应该如何组织？数据库连接池如何与异步的请求处理器协同工作？对于可能源自数据库、外部API调用或用户输入的多种错误，最佳的处理策略是什么？

这些问题不再是关于某个单一的Rust特性，而是关于_如何使用Rust进行系统设计_。要回答它们，就必须综合运用整个语言及其生态系统的知识。例如，开发者会通过实践认识到，`anyhow`库非常适合处理应用程序顶层的错误，而对于一个可复用的库，定义自定义的错误`enum`则更为恰当。他会学习使用Cargo Workspaces来管理一个微服务项目。因此，成功完成一个非凡的项目，不仅是对其已有技能的真实检验，更是从一个“了解Rust的人”转变为一个真正的“Rust开发者”的必经之路。  

### 表2：高级项目式学习路线图

下表为高级学习者提供了一个结构化的指南，帮助他们选择符合个人兴趣和职业目标的项目领域，并指明了成功所需的关键资源和核心概念。

|项目领域|示例项目|掌握的核心概念|权威资源|核心生态Crates|
|---|---|---|---|---|
|**命令行工具**|重新实现`grep`|文件I/O, TDD, 性能分析|《Command Line Applications in Rust》|`clap`, `anyhow`|
|**后端服务**|REST API|`async/await`, 并发, 数据库迁移, API设计|《Zero to Production in Rust》|`tokio`, `axum`, `sqlx`, `serde`|
|**WebAssembly (Wasm)**|浏览器内视频滤镜|JS互操作(FFI), DOM操作, 二进制体积优化|《Rust and WebAssembly》|`wasm-bindgen`, `yew`|
|**嵌入式系统**|树莓派OS内核|`no_std`, 内存映射I/O, 中断, 交叉编译|《The Embedded Rust Book》|`cortex-m`, 各种HAL crates|

 

---

## 第四部分：综合与持续成长

最后一部分旨在指导学习者如何将前述各阶段的学习整合成一个连贯的、长期的职业发展策略。

### 4.1 打造个性化的学习轨迹

本节将综合前文的分析，为不同类型的开发者角色勾勒出示例性的学习路径：

- **后端开发者路径:**
    
    1. **基础:** 《The Book》 + Rustlings。
        
    2. **强化:** 专注于Exercism以掌握地道的代码风格。
        
    3. **应用:** 深入学习《Zero to Production in Rust》，并以此为基础，使用`axum`和`sqlx`构建一个自定义的微服务。
        
- **系统程序员路径:**
    
    1. **基础:** 《The Book》 + Rustlings。
        
    2. **强化:** 使用Codewars/LeetCode来训练算法效率。
        
    3. **应用:** 首先完成“The Book”中的`grep`克隆项目，然后从`build-your-own-x-in-rust`列表中选择一个更具挑战性的项目，如实现一个Shell或一个简单的文件系统。
        
- **前端/Wasm专家路径:**
    
    1. **基础:** 《The Book》 + Rustlings。
        
    2. **强化:** 完成《Rust and WebAssembly》书中的教程。
        
    3. **应用:** 选择一个计算密集型的JavaScript库，并用Rust/Wasm重新实现它，以体验性能上的巨大提升。
        

### 4.2 融入生态系统：从学习者到贡献者

#### 善用“Awesome Rust”资源列表

在开始一个新项目时，开发者需要了解生态系统中已有的工具。社区维护了多个高质量的“Awesome Rust”列表，如`uhub/awesome-rust`和`rust-unofficial/awesome-rust`等。这些仓库分门别类地整理了海量的框架、库和工具，覆盖了从日志记录到图形用户界面（GUI）开发的方方面面。对于项目开发者而言，这些列表是不可或缺的宝库，可以帮助他们快速找到满足特定需求的、经过社区检验的优秀crates，从而避免“重复造轮子”，极大地提高开发效率。  

#### 终极一步：开源贡献

掌握一门技术的最终检验标准，是能够为现有的开源项目做出贡献。这个过程要求开发者具备阅读、理解并扩展复杂的生产级代码库的能力。

对于希望迈出这一步的开发者，建议从自己学习项目中用过的某个开源库开始。可以先从一些小处着手，例如修正文档中的拼写错误、解决被标记为“good first issue”的简单问题，或者添加一些小的、非核心的功能。这个过程不仅能进一步深化对Rust的理解，也是从一个知识的消费者转变为Rust社区积极参与者和贡献者的标志，完成了从引导式学习到积极回馈社区的完整循环。  

## 结论

### 学习之旅的回顾

精通Rust的道路是一段循序渐进的旅程。本报告提出的三阶段路径——通过基础练习掌握编译器的逻辑，通过实践平台锤炼地道的编程风格，最终通过构建复杂的真实世界项目达成深度理解——为这段旅程提供了一份清晰的地图。

### 最终寄语

学习Rust是一场马拉松，而非百米冲刺。本报告所勾勒的路线图，旨在使这段旅程更加高效、富有成效，并最终带来深刻的回报。其最终目标是赋予开发者信心与能力，去构建那些可靠且高性能的软件——这正是Rust语言对世界的承诺。通过持续的实践和社区参与，任何有志于此的开发者都能攀登Rust的学习高峰，并领略其顶峰的壮丽风景